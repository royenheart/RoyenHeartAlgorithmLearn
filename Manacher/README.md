###  Manacher算法试水 

给定序列，求出该序列的以各个元素为对称中心的回文子串的半径

Manacher算法原理：

本质是**中心对称子串方法**的拓展

**中心对称子串方法**：对一个字符串，对其中所有元素以其为回文子串的对称中心进行遍历查找其回文半径，这种方法较为简单，但时间复杂度为O(n^2^)。

Manacher也是运用了中心对称子串的方法，但是通过保留序列先前元素的回文子串半径来进行快速运算，其时间复杂度为O(n)。

其原理是：  
由于存在奇数项的回文子串和偶数项的回文子串，对于回文半径的运算有所影响，因此我们对原先的字符串进行修改，在每两个字符和字符串左右两边插入辅助字符（可自定义），有必要可以再在修改后的字符串左右两边加入两个不相同的辅助字符（三个辅助字符要不同），以防范围溢出。

![img01](https://imgconvert.csdnimg.cn/aHR0cHM6Ly9waWM0LnpoaW1nLmNvbS84MC92Mi1kNTcwZjdhOWU3MzJkNTc3ZDU1NmIwZTZjZmYxZDI2M19oZC5qcGc?x-oss-process=image/format,pnghttps://imgconvert.csdnimg.cn/aHR0cHM6Ly9waWM0LnpoaW1nLmNvbS84MC92Mi1kNTcwZjdhOWU3MzJkNTc3ZDU1NmIwZTZjZmYxZDI2M19oZC5qcGc?x-oss-process=image/format,png)

**来自于CSDN**

首先我们需要：
| 量  | 说明                                                                      |
| --- | ------------------------------------------------------------------------- |
| i   | 当前索引位置，即字符串当前指向的字符                                      |
| R   | 最长回文右边界，表示以i之前的元素为对称中心所能延伸到的回文子串的最右边界 |
| C   | 即当前拥有最右边界的回文子串的对称中心                                    |

同时我们需要Radius[]数组来存储对应字符串位置的回文半径。

初始化R = -1;C = -1;

当i > R时，表示右边界会被拓展，则此时对i做中心回文子串的运算，更新R，C，Radius[i]

当i <= R时，我们可以知道此时i处于以C为对称中心的回文子串中，根据回文子串的性质，我们可以看到i关于C的镜像Mirror(i)与i的性质在很大程度上相似，具体表现在两者的回文半径上：

1. 若Radius[Mirror(i)] < R-i+1，即镜像的回文半径小于R到i的距离，根据回文子串的定义以及镜像的关系，Radius[i] = Radius[Mirror(i)]，此时的意义是镜像的回文包含于C的回文中。
2. 若Radius[Mirror(i)] > R-i+1，即镜像的回文半径大于R到i的距离，则此时Radius[i] = R-i+1，此时的意义是镜像部分回文子串处于C的回文子串之中
3. 若Radius[Mirror(i)] = R-i+1，即镜像的回文半径等于R到i的距离，此时表明镜像的回文正好触及左边界，相对于i来说这一部分是它的回文子串的一部分，由于右边未知，因此对i在R之后进行中心回文子串的查找运算，更新Radius[i]以及R与C。

由此我们可以得到每个位置对应的回文半径。Manacher算法保留了先前元素的回文半径以此计算当前元素的回文半径，我们可以看到，R本身并不会后退而是不断拓展至字符串尾，无需对每个元素做中心回文子串的查找，因此算法复杂度为O(n)